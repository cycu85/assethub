# KONTEKS APLIKACJI ASSETHUB - PRZEWODNIK DLA GENERATORÓW AI

## ARCHITEKTURA I KONWENCJE

### Struktura aplikacji
- **Framework**: Symfony 7.0 + PHP 8.2+
- **Baza danych**: MySQL/MariaDB z Doctrine ORM
- **Frontend**: Bootstrap 5.3 + Twig templates + vanilla JavaScript
- **Autoryzacja**: Enterprise-grade system z AuthorizationService
- **Logowanie**: Kompleksowe audyty przez AuditService z wielopoziomowym logowaniem
- **Architektura**: Service Layer Pattern + CQRS + Event-Driven Architecture

### Konwencje nazewnictwa
- **Kontrolery**: `{Module}Controller` (np. EquipmentController)
- **Encje**: Singular form (User, Equipment, Module)
- **Repozytoria**: `{Entity}Repository`
- **Formularze**: `{Purpose}Type` (np. EquipmentCreateType)
- **Serwisy**: `{Purpose}Service` (np. EquipmentService, AuthorizationService, AuditService)
- **Commands**: `{Action}{Entity}Command` (np. CreateEquipmentCommand)
- **Queries**: `Get{Entity}Query` (np. GetEquipmentQuery)
- **Events**: `{Entity}{Action}Event` (np. EquipmentCreatedEvent)
- **Event Subscribers**: `{Module}EventSubscriber` (np. EquipmentEventSubscriber)
- **Szablony**: `{module}/{action}.html.twig`

## ARCHITEKTURA ENTERPRISE

### Service Layer Pattern
Wszystkie kontrolery używają warstwy serwisów dla separacji logiki biznesowej:

```php
// Kontroler - tylko warstwa prezentacji
public function create(Request $request): Response
{
    $user = $this->getUser();
    
    // Autoryzacja przez AuthorizationService
    $this->authorizationService->checkPermission($user, 'equipment', 'CREATE', $request);
    
    if ($form->isSubmitted() && $form->isValid()) {
        // Logika biznesowa w serwisie
        $equipment = $this->equipmentService->createEquipment($data, $user);
        
        // Event dla loose coupling
        $event = new EquipmentCreatedEvent($equipment, $user, $context);
        $this->eventDispatcher->dispatch($event, EquipmentCreatedEvent::NAME);
        
        return $this->redirectToRoute('equipment_index');
    }
    
    return $this->render('equipment/new.html.twig', ['form' => $form]);
}
```

### CQRS Pattern (Command Query Responsibility Segregation)
Separacja komend i zapytań:

```php
// Command - dla operacji zapisu
$command = new CreateEquipmentCommand(
    name: $data['name'],
    description: $data['description'],
    categoryId: $data['category'],
    createdById: $user->getId()
);

// Query - dla operacji odczytu  
$query = new GetEquipmentQuery(
    page: $request->query->getInt('page', 1),
    limit: 25,
    search: $request->query->get('search'),
    filters: $filters
);
```

### Event-Driven Architecture
Zdarzenia domenowe z subskrybentami:

```php
// Event
class EquipmentCreatedEvent extends Event
{
    public const NAME = 'equipment.created';
    
    public function __construct(
        private Equipment $equipment,
        private User $createdBy,
        private array $context = []
    ) {}
}

// Event Subscriber
class EquipmentEventSubscriber implements EventSubscriberInterface
{
    public static function getSubscribedEvents(): array
    {
        return [
            EquipmentCreatedEvent::NAME => [
                ['onEquipmentCreated', 10],
                ['checkHighValueEquipment', 5],
            ],
        ];
    }
    
    public function onEquipmentCreated(EquipmentCreatedEvent $event): void
    {
        // Kompleksowy audit
        $this->auditService->logUserAction($event->getCreatedBy(), 'equipment_created_event', [
            'equipment_id' => $event->getEquipment()->getId(),
            'equipment_name' => $event->getEquipment()->getName(),
            'context' => $event->getContext()
        ]);
        
        // Wysyłanie powiadomień email (opcjonalnie)
        if ($this->mailer) {
            $this->sendCreationNotification($event);
        }
    }
}
```

### AuthorizationService - Centralizowana Autoryzacja
Zastąpił stary PermissionService:

```php
// W kontrolerach - ZAWSZE na początku akcji
$this->authorizationService->checkModuleAccess($user, 'equipment', $request);
$this->authorizationService->checkPermission($user, 'equipment', 'CREATE', $request);

// Sprawdzanie uprawnień
$canEdit = $this->authorizationService->hasPermission($user, 'equipment', 'EDIT');
$canEditAny = $this->authorizationService->hasAnyPermission($user, 'equipment', ['EDIT', 'DELETE']);

// Właścicielstwo zasobów
$canEditResource = $this->authorizationService->canEditResource($user, $equipment);

// Pobieranie modułów użytkownika
$availableModules = $this->authorizationService->getUserModules($user);
```

### AuditService - Kompleksowy System Audytu
Zunifikowane logowanie wszystkich działań:

```php
// Akcje użytkowników
$this->auditService->logUserAction($user, 'view_equipment_index', [
    'page' => $page,
    'filters' => $filters,
    'total_equipment' => $equipmentCount
], $request);

// Zdarzenia bezpieczeństwa
$this->auditService->logSecurityEvent('failed_login', $user, [
    'attempts' => $attempts,
    'locked_until' => $lockTime
], $request, 'high');

// Operacje CRUD
$this->auditService->logCrudOperation($user, 'Equipment', $equipment->getId(), 'CREATE', $data, $request);

// Akcje administracyjne
$this->auditService->logAdminAction($admin, 'database_backup_created', [
    'filename' => $filename,
    'size' => $fileSize
], $request);

// Operacje bazy danych
$this->auditService->logDatabaseOperation($admin, 'optimize', true, [
    'optimized_tables' => $count,
    'duration' => $duration
], $request);
```

## SERWISY BIZNESOWE

### EquipmentService - Zarządzanie Sprzętem
Kompletna logika biznesowa sprzętu:

```php
// CRUD Operations
$equipment = $this->equipmentService->createEquipment($data, $user);
$equipment = $this->equipmentService->updateEquipment($equipment, $context, $user);
$this->equipmentService->deleteEquipment($equipment, $user);

// Business Operations
$equipment = $this->equipmentService->assignEquipment($equipment, $assignee, $assignedBy, $notes);
$equipment = $this->equipmentService->unassignEquipment($equipment, $user);
$equipment = $this->equipmentService->markAsDamaged($equipment, $user, $description);

// Queries
$pagination = $this->equipmentService->getEquipmentWithPagination($page, $limit, $filters);
$statistics = $this->equipmentService->getEquipmentStatistics();
$results = $this->equipmentService->searchEquipment($query, $limit);
$userEquipment = $this->equipmentService->getUserAssignedEquipment($user);
$categoryData = $this->equipmentService->getEquipmentByCategory($categoryId);
```

### AdminService - Operacje Administracyjne
Zarządzanie systemem i danymi:

```php
// System Management
$result = $this->adminService->resetGeneralSettingsToDefaults($admin);
$systemInfo = $this->adminService->getSystemInfo();
$dashboardData = $this->adminService->getDashboardData();

// Database Operations  
$filename = $this->adminService->createDatabaseBackup();
$result = $this->adminService->performDatabaseMaintenance('optimize');
$result = $this->adminService->clearSystemLogs(['application', 'security']);

// Backup Management
$backups = $this->adminService->listBackups();
$result = $this->adminService->cleanupOldBackups($daysToKeep, $admin);
```

## SYSTEM MODUŁOWY - ENTERPRISE EDITION

### Autoryzacja modułowa
Każdy moduł ma:
1. Wpis w tabeli `modules` (nazwa, opis, czy aktywny)
2. Role przypisane do modułów w tabeli `roles`
3. Użytkownicy mają role przez tabelę `user_roles`
4. Kontrolery sprawdzają uprawnienia przez `AuthorizationService`

### Dodawanie nowego modułu - KOMPLETNY CHECKLIST:

#### 1. BAZA DANYCH
```sql
-- Dodaj moduł
INSERT INTO modules (name, display_name, description, is_active, sort_order) 
VALUES ('new_module', 'Nowy Moduł', 'Opis nowego modułu', 1, 100);

-- Dodaj role
INSERT INTO roles (name, display_name, description, permissions, module_id) VALUES
('NEW_MODULE_ADMIN', 'Administrator', 'Pełny dostęp', 'VIEW,CREATE,EDIT,DELETE', LAST_INSERT_ID()),
('NEW_MODULE_USER', 'Użytkownik', 'Tylko podgląd', 'VIEW', LAST_INSERT_ID());
```

#### 2. SERWIS BIZNESOWY (src/Service/)
```php
class NewModuleService
{
    public function __construct(
        private NewModuleRepository $repository,
        private EntityManagerInterface $entityManager,
        private AuditService $auditService,
        private LoggerInterface $logger,
        private ValidatorInterface $validator
    ) {}
    
    public function createEntity(array $data, User $user): NewModuleEntity
    {
        // Walidacja biznesowa
        if (empty($data['name'])) {
            throw new ValidationException('Name is required');
        }
        
        // Tworzenie encji
        $entity = new NewModuleEntity();
        $this->populateFromArray($entity, $data);
        $entity->setCreatedBy($user);
        
        // Walidacja Symfony
        $violations = $this->validator->validate($entity);
        if (count($violations) > 0) {
            throw new ValidationException('Validation errors', $violations);
        }
        
        // Persystencja
        $this->entityManager->persist($entity);
        $this->entityManager->flush();
        
        // Audit
        $this->auditService->logCrudOperation($user, 'NewModuleEntity', $entity->getId(), 'CREATE', $data);
        
        // Logging
        $this->logger->info('New module entity created', [
            'entity_id' => $entity->getId(),
            'user' => $user->getUsername()
        ]);
        
        return $entity;
    }
}
```

#### 3. KONTROLERY - ENTERPRISE PATTERN
```php
#[Route('/new-module')]
class NewModuleController extends AbstractController
{
    public function __construct(
        private AuthorizationService $authorizationService,
        private AuditService $auditService,
        private NewModuleService $newModuleService,
        private EventDispatcherInterface $eventDispatcher,
        private LoggerInterface $logger
    ) {}

    #[Route('/', name: 'new_module_index')]
    public function index(Request $request): Response
    {
        $user = $this->getUser();
        
        // Autoryzacja
        $this->authorizationService->checkModuleAccess($user, 'new_module', $request);
        
        // Business logic via service
        $pagination = $this->newModuleService->getPaginatedList($request->query->all());
        
        // Audit
        $this->auditService->logUserAction($user, 'view_new_module_index', [], $request);
        
        return $this->render('new_module/index.html.twig', [
            'entities' => $pagination,
            'can_create' => $this->authorizationService->hasPermission($user, 'new_module', 'CREATE'),
            'can_edit' => $this->authorizationService->hasPermission($user, 'new_module', 'EDIT'),
        ]);
    }
    
    #[Route('/new', name: 'new_module_new')]
    public function new(Request $request): Response
    {
        $user = $this->getUser();
        
        // Autoryzacja
        $this->authorizationService->checkPermission($user, 'new_module', 'CREATE', $request);
        
        $form = $this->createForm(NewModuleType::class);
        $form->handleRequest($request);
        
        if ($form->isSubmitted() && $form->isValid()) {
            try {
                // Command pattern
                $command = new CreateNewModuleCommand(
                    name: $form->get('name')->getData(),
                    description: $form->get('description')->getData(),
                    // ...
                );
                
                // Business logic via service
                $entity = $this->newModuleService->createEntity($command->toArray(), $user);
                
                // Domain event
                $event = new NewModuleCreatedEvent($entity, $user, [
                    'source' => 'web_form',
                    'ip' => $request->getClientIp()
                ]);
                $this->eventDispatcher->dispatch($event, NewModuleCreatedEvent::NAME);
                
                $this->addFlash('success', 'Entity created successfully.');
                return $this->redirectToRoute('new_module_index');
                
            } catch (ValidationException $e) {
                $this->addFlash('error', 'Validation error: ' . $e->getMessage());
            } catch (\Exception $e) {
                $this->addFlash('error', 'Unexpected error occurred.');
                $this->logger->error('Failed to create new module entity', [
                    'error' => $e->getMessage(),
                    'user' => $user->getUsername()
                ]);
            }
        }
        
        return $this->render('new_module/new.html.twig', ['form' => $form]);
    }
}
```

#### 4. COMMAND/QUERY PATTERN
```php
// Command (src/Command/NewModule/)
class CreateNewModuleCommand
{
    public function __construct(
        public readonly string $name,
        public readonly ?string $description = null,
        public readonly ?int $categoryId = null
    ) {}
    
    public function toArray(): array
    {
        return [
            'name' => $this->name,
            'description' => $this->description,
            'categoryId' => $this->categoryId
        ];
    }
}

// Query (src/Query/NewModule/)
class GetNewModuleQuery
{
    public function __construct(
        public readonly int $page = 1,
        public readonly int $limit = 25,
        public readonly ?string $search = null,
        public readonly array $filters = []
    ) {}
}
```

#### 5. EVENT SYSTEM
```php
// Event (src/Event/NewModule/)
class NewModuleCreatedEvent extends Event
{
    public const NAME = 'new_module.created';
    
    public function __construct(
        private NewModuleEntity $entity,
        private User $createdBy,
        private array $context = []
    ) {}
    
    // getters...
}

// Event Subscriber (src/EventSubscriber/)
class NewModuleEventSubscriber implements EventSubscriberInterface
{
    public function __construct(
        private AuditService $auditService,
        private LoggerInterface $logger,
        private ?MailerInterface $mailer = null
    ) {}
    
    public static function getSubscribedEvents(): array
    {
        return [
            NewModuleCreatedEvent::NAME => [
                ['onEntityCreated', 10],
                ['sendNotification', 5],
            ],
        ];
    }
    
    public function onEntityCreated(NewModuleCreatedEvent $event): void
    {
        $this->auditService->logUserAction($event->getCreatedBy(), 'new_module_created_event', [
            'entity_id' => $event->getEntity()->getId(),
            'entity_name' => $event->getEntity()->getName(),
            'context' => $event->getContext()
        ]);
    }
}
```

## TESTY JEDNOSTKOWE - ENTERPRISE COVERAGE

### Struktura testów
```
tests/
├── Controller/
│   ├── EquipmentControllerTest.php      # ✅ 12 testów
│   ├── DashboardControllerTest.php      # ✅ 7 testów
│   ├── SearchControllerTest.php         # ✅ 8 testów
│   └── {Module}ControllerTest.php
├── Service/
│   ├── AuthorizationServiceTest.php     # ✅ 17 testów
│   ├── AuditServiceTest.php            # ✅ 15 testów
│   ├── EquipmentServiceTest.php        # ✅ 18 testów
│   ├── AdminServiceTest.php            # ✅ 12 testów
│   └── {Service}Test.php
└── Entity/
    └── {Entity}Test.php
```

### Pattern testów dla serwisów
```php
class NewModuleServiceTest extends TestCase
{
    private NewModuleService $service;
    private MockObject|EntityManagerInterface $entityManagerMock;
    private MockObject|AuditService $auditServiceMock;
    
    protected function setUp(): void
    {
        $this->entityManagerMock = $this->createMock(EntityManagerInterface::class);
        $this->auditServiceMock = $this->createMock(AuditService::class);
        
        $this->service = new NewModuleService(
            $this->repositoryMock,
            $this->entityManagerMock,
            $this->auditServiceMock,
            $this->loggerMock,
            $this->validatorMock
        );
    }
    
    public function testCreateEntitySuccessfully(): void
    {
        // Arrange
        $data = ['name' => 'Test Entity'];
        $user = $this->createTestUser();
        
        $this->validatorMock->expects($this->once())
            ->method('validate')
            ->willReturn(new ConstraintViolationList());
            
        $this->entityManagerMock->expects($this->once())
            ->method('persist');
            
        $this->auditServiceMock->expects($this->once())
            ->method('logCrudOperation');
        
        // Act
        $entity = $this->service->createEntity($data, $user);
        
        // Assert
        $this->assertInstanceOf(NewModuleEntity::class, $entity);
        $this->assertEquals('Test Entity', $entity->getName());
    }
}
```

### Pattern testów dla kontrolerów
```php
class NewModuleControllerTest extends WebTestCase
{
    private $client;
    private MockObject|AuthorizationService $authorizationServiceMock;
    private MockObject|AuditService $auditServiceMock;
    
    protected function setUp(): void
    {
        $this->client = static::createClient();
        
        // Mock services in container
        $container = self::getContainer();
        $container->set(AuthorizationService::class, $this->authorizationServiceMock);
        $container->set(AuditService::class, $this->auditServiceMock);
    }
    
    public function testIndexActionWithAuthenticatedUser(): void
    {
        $user = $this->createTestUser();
        $this->client->loginUser($user);
        
        $this->authorizationServiceMock->expects($this->once())
            ->method('checkModuleAccess')
            ->with($user, 'new_module');
            
        $this->auditServiceMock->expects($this->once())
            ->method('logUserAction');
        
        $this->client->request('GET', '/new-module/');
        
        $this->assertResponseIsSuccessful();
    }
}
```

## WYSZUKIWANIE GLOBALNE

### SearchController - Enterprise Search
Rozszerzony system wyszukiwania:

```php
// Multi-module search z rate limiting
public function search(Request $request): JsonResponse
{
    $user = $this->getUser();
    
    // Rate limiting
    $limiter = $this->searchLimiter->create($user->getId());
    if (!$limiter->consume(1)->isAccepted()) {
        $this->auditService->logSecurityEvent('search_rate_limit_exceeded', $user);
        throw new TooManyRequestsHttpException(60);
    }
    
    $results = [];
    
    // Wyszukiwanie w użytkownikach
    if ($this->authorizationService->hasModuleAccess($user, 'employees')) {
        $users = $this->searchUsers($query);
        // Transform to unified result format
    }
    
    // Wyszukiwanie w sprzęcie
    if ($this->authorizationService->hasAnyPermission($user, 'equipment', ['VIEW'])) {
        $equipment = $this->equipmentService->searchEquipment($query, 5);
        // Transform to unified result format
    }
    
    // Audit search
    $this->auditService->logUserAction($user, 'global_search', [
        'query' => $query,
        'results_count' => count($results),
        'types_searched' => $typesSearched
    ], $request);
    
    return new JsonResponse([
        'results' => array_slice($results, 0, 10),
        'total' => count($results),
        'query' => $query
    ]);
}
```

## DASHBOARD - ENTERPRISE METRICS

### DashboardController - Smart Dashboard
Inteligentny dashboard z metrykami:

```php
public function index(Request $request): Response
{
    $user = $this->getUser();
    
    // Pobierz dostępne moduły
    $availableModules = $this->authorizationService->getUserModules($user);
    
    // Inteligentne statystyki w zależności od uprawnień
    $dashboardStats = $this->getDashboardStats($user);
    
    // Audit
    $this->auditService->logUserAction($user, 'view_dashboard', [
        'modules_count' => count($availableModules),
        'has_equipment_access' => in_array('equipment', array_column($availableModules, 'name'))
    ], $request);
    
    return $this->render('dashboard/index.html.twig', [
        'user' => $user,
        'modules' => $availableModules,
        'stats' => $dashboardStats,
    ]);
}

private function getDashboardStats($user): array
{
    $stats = [
        'total_equipment' => 0,
        'my_equipment' => 0,
        'available_equipment' => 0,
        'damaged_equipment' => 0
    ];
    
    // Tylko dla użytkowników z dostępem do sprzętu
    if ($this->authorizationService->hasAnyPermission($user, 'equipment', ['VIEW', 'EDIT'])) {
        try {
            $equipmentStats = $this->equipmentService->getEquipmentStatistics();
            $stats = array_merge($stats, $equipmentStats);
            
            $userEquipment = $this->equipmentService->getUserAssignedEquipment($user);
            $stats['my_equipment'] = count($userEquipment);
        } catch (\Exception $e) {
            $this->logger->warning('Failed to load dashboard equipment stats', [
                'user' => $user->getUsername(),
                'error' => $e->getMessage()
            ]);
        }
    }
    
    return $stats;
}
```

## SYSTEM PROFILI - ROZSZERZONY

### ProfileController - Enterprise Profile Management
Zarządzanie profilami użytkowników z audytem:

```php
public function index(Request $request, UserPasswordHasherInterface $passwordHasher, EntityManagerInterface $entityManager): Response
{
    $user = $this->getUser();
    
    // Audit profile access
    $this->auditService->logUserAction($user, 'view_profile', [], $request);
    
    // Obsługa zmiany hasła z audytem
    if ($changePasswordForm->isSubmitted() && $changePasswordForm->isValid()) {
        if (!$passwordHasher->isPasswordValid($user, $data['currentPassword'])) {
            // Audit failed password change
            $this->auditService->logSecurityEvent('password_change_failed_invalid_current', $user, [
                'reason' => 'invalid_current_password'
            ], $request);
        } else {
            // Successful password change
            $this->auditService->logSecurityEvent('password_changed', $user, [
                'changed_by_user' => true
            ], $request);
        }
    }
    
    // Avatar upload z audytem
    if ($avatarUploadForm->isSubmitted() && $avatarUploadForm->isValid()) {
        $result = $this->handleAvatarUpload($avatarFile, $user, $slugger, $entityManager);
        
        if ($result['success']) {
            $this->auditService->logUserAction($user, 'avatar_changed', [
                'filename' => $result['filename'],
                'file_size' => $result['file_size']
            ], $request);
        }
    }
}
```

## BAZA DANYCH - ENTERPRISE MANAGEMENT

### AdminService - Zaawansowane zarządzanie bazą
Profesjonalne narzędzia administracyjne:

```php
// Dashboard z metrykami systemowymi
public function getDashboardData(): array
{
    return [
        'system_stats' => [
            'users_count' => $this->entityManager->getRepository('App\\Entity\\User')->count([]),
            'equipment_count' => $this->entityManager->getRepository('App\\Entity\\Equipment')->count([]),
            'active_sessions' => 0, // TODO: Implement session counting
        ],
        'recent_activities' => [], // Recent audit logs
        'system_info' => $this->getSystemInfo()
    ];
}

// Backup z kompatybilnością
public function createDatabaseBackup(): string
{
    $connection = $this->entityManager->getConnection();
    $databaseName = $connection->getDatabase();
    
    if (!$this->isMySQLPlatform($connection->getDatabasePlatform())) {
        throw new DatabaseException('Backup jest obsługiwany tylko dla MySQL');
    }
    
    $backupDir = $this->kernel->getProjectDir() . '/var/backups';
    $filename = 'backup_' . $databaseName . '_' . date('Y-m-d_H-i-s') . '.sql';
    $filepath = $backupDir . '/' . $filename;
    
    // Bezpieczne wykonanie mysqldump
    $params = $connection->getParams();
    $command = sprintf(
        'mysqldump -h%s -P%s -u%s -p%s --single-transaction --routines --triggers %s > %s',
        escapeshellarg($params['host']),
        escapeshellarg($params['port']),
        escapeshellarg($params['user']),
        escapeshellarg($params['password']),
        escapeshellarg($databaseName),
        escapeshellarg($filepath)
    );
    
    exec($command, $output, $returnCode);
    
    if ($returnCode !== 0 || !file_exists($filepath)) {
        throw new DatabaseException('Backup nie powiódł się');
    }
    
    return $filename;
}
```

## BEZPIECZEŃSTWO - ENTERPRISE GRADE

### Kompleksowy system audytu
```php
// Różne poziomy logowania
$this->auditService->logUserAction($user, 'action', $data, $request);          // INFO
$this->auditService->logSecurityEvent('event', $user, $data, $request, 'high'); // ERROR  
$this->auditService->logAdminAction($admin, 'action', $data, $request);         // NOTICE
$this->auditService->logDatabaseOperation($user, 'backup', true, $data);       // NOTICE/ERROR

// Automatyczna sanityzacja danych wrażliwych
private function sanitizeData(array $data): array
{
    $sensitiveKeys = ['password', 'token', 'api_key', 'secret'];
    
    foreach ($sensitiveKeys as $key) {
        if (isset($data[$key])) {
            $data[$key] = '***';
        }
    }
    
    return $data;
}

// Context z request information
private function getRequestContext(?Request $request): array
{
    if (!$request) {
        return [
            'ip_address' => 'CLI',
            'user_agent' => 'CLI',
            'method' => 'CLI',
            'uri' => 'CLI',
            'timestamp' => new \DateTime()
        ];
    }
    
    return [
        'ip_address' => $request->getClientIp(),
        'user_agent' => $request->headers->get('User-Agent'),
        'method' => $request->getMethod(),
        'uri' => $request->getRequestUri(),
        'timestamp' => new \DateTime()
    ];
}
```

### Rate Limiting w SearchController
```php
// Rate limiting z audytem
$limiter = $this->searchLimiter->create($user->getId());
if (!$limiter->consume(1)->isAccepted()) {
    $this->auditService->logSecurityEvent('search_rate_limit_exceeded', $user, [
        'attempted_query' => $request->query->get('q', '')
    ], $request);
    throw new TooManyRequestsHttpException(60, 'Too many search requests');
}
```

## KOMPATYBILNOŚĆ I NAJLEPSZE PRAKTYKI

### Doctrine DBAL - Kompatybilność
```php
// POPRAWNE - kompatybilne z nowszymi wersjami
private function isMySQLPlatform($platform): bool
{
    return $platform instanceof \Doctrine\DBAL\Platforms\MySQLPlatform;
}

private function getDatabaseTypeName($platform): string
{
    if ($platform instanceof \Doctrine\DBAL\Platforms\MySQLPlatform) {
        return 'mysql';
    } elseif ($platform instanceof \Doctrine\DBAL\Platforms\PostgreSQLPlatform) {
        return 'postgresql';
    }
    
    return 'unknown';
}
```

### Exception Handling
```php
// Centralizowana obsługa błędów
try {
    $result = $this->businessService->performOperation($data, $user);
} catch (ValidationException $e) {
    $this->addFlash('error', 'Błąd walidacji: ' . $e->getMessage());
    $this->auditService->logUserAction($user, 'operation_failed_validation', [
        'error' => $e->getMessage(),
        'data' => $this->auditService->sanitizeData($data)
    ], $request);
} catch (BusinessLogicException $e) {
    $this->addFlash('error', $e->getMessage());
    $this->auditService->logUserAction($user, 'operation_failed_business_logic', [
        'error' => $e->getMessage()
    ], $request);
} catch (\Exception $e) {
    $this->addFlash('error', 'Wystąpił nieoczekiwany błąd.');
    $this->logger->error('Unexpected error in operation', [
        'user' => $user->getUsername(),
        'error' => $e->getMessage(),
        'trace' => $e->getTraceAsString()
    ]);
}
```

## DEPLOYMENT CHECKLIST - ENTERPRISE

### Pre-deployment dla nowego modułu:
- [ ] **Serwis biznesowy** utworzony z pełnym API
- [ ] **Kontroler** używa Service Layer + AuthorizationService + AuditService
- [ ] **CQRS Commands/Queries** zaimplementowane
- [ ] **Event System** skonfigurowany z subskrybentami
- [ ] **Testy jednostkowe** napisane (service + controller)
- [ ] **Migracje bazy danych** przetestowane  
- [ ] **Fixtures** zaktualizowane
- [ ] **Autoryzacja** skonfigurowana przez AuthorizationService
- [ ] **Audit logging** zaimplementowany we wszystkich akcjach
- [ ] **Exception handling** centralizowany
- [ ] **Rate limiting** gdzie potrzebne
- [ ] **Walidacja** na poziomie biznesowym i Symfony
- [ ] **Dokumentacja** zaktualizowana
- [ ] **Cache** wyczyszczony na produkcji

---

**ARCHITEKTURA ENTERPRISE ASSETHUB:**
- ✅ Service Layer Pattern
- ✅ CQRS (Command Query Responsibility Segregation)  
- ✅ Event-Driven Architecture
- ✅ Centralizowana autoryzacja (AuthorizationService)
- ✅ Kompleksowy audit trail (AuditService)
- ✅ Pełne pokrycie testami jednostkowymi
- ✅ Exception handling i error recovery
- ✅ Rate limiting i security measures
- ✅ Business logic validation
- ✅ Enterprise database management

## MENU BOCZNE - ZACHOWANIE STANU ROZWINIĘCIA

### Implementacja inteligentnego menu
Menu boczne w `templates/partials/sidebar.html.twig` automatycznie zachowuje stan rozwinięcia podmenu:

```twig
{# Sprawdzenie aktualnej route i sekcji #}
{% set current_route = app.request.get('_route') %}
{% set is_admin_section = current_route starts with 'admin_' and not (current_route starts with 'admin_users') %}

<li class="nav-item">
    <a class="nav-link menu-link {{ is_admin_section ? 'active' : '' }}" 
       href="#sidebarAdmin" 
       data-bs-toggle="collapse" 
       role="button" 
       aria-expanded="{{ is_admin_section ? 'true' : 'false' }}" 
       aria-controls="sidebarAdmin">
        <i class="ri-settings-3-line"></i> <span>Panel administracyjny</span>
    </a>
    <div class="collapse menu-dropdown {{ is_admin_section ? 'show' : '' }}" id="sidebarAdmin">
        <ul class="nav nav-sm flex-column">
            <li class="nav-item">
                <a href="{{ path('admin_dashboard') }}" class="nav-link {{ current_route == 'admin_dashboard' ? 'active' : '' }}">Panel główny</a>
            </li>
            <!-- inne pozycje menu -->
        </ul>
    </div>
</li>
```

### WZORZEC dla nowych pozycji menu z podmenu

Aby nowe pozycje menu z podmenu zachowywały stan rozwinięcia, użyj tego wzorca:

```twig
{% set current_route = app.request.get('_route') %}
{% set is_module_section = current_route starts with 'module_prefix_' %}

<li class="nav-item">
    <a class="nav-link menu-link {{ is_module_section ? 'active' : '' }}" 
       href="#sidebarModuleName" 
       data-bs-toggle="collapse" 
       role="button" 
       aria-expanded="{{ is_module_section ? 'true' : 'false' }}" 
       aria-controls="sidebarModuleName">
        <i class="ri-icon-name"></i> <span>Nazwa Modułu</span>
    </a>
    <div class="collapse menu-dropdown {{ is_module_section ? 'show' : '' }}" id="sidebarModuleName">
        <ul class="nav nav-sm flex-column">
            <li class="nav-item">
                <a href="{{ path('module_route1') }}" class="nav-link {{ current_route starts with 'module_route1' ? 'active' : '' }}">Pozycja 1</a>
            </li>
            <li class="nav-item">
                <a href="{{ path('module_route2') }}" class="nav-link {{ current_route starts with 'module_route2' ? 'active' : '' }}">Pozycja 2</a>
            </li>
        </ul>
    </div>
</li>
```

**WAŻNE zasady:**
- Zastąp `'module_prefix_'` prefiksem swoich route'ów  
- Użyj unikalnego ID dla `sidebarModuleName`
- Dodaj odpowiednie klasy `'active'` dla podmenu
- Użyj `'starts with'` dla route'ów z wieloma akcjami (edit, create, show)
- Użyj `'=='` dla pojedynczych route'ów

### Funkcjonalność
- ✅ Menu pozostaje rozwinięte przy przejściu między podstronami tej samej sekcji
- ✅ Menu automatycznie się zwija przy przejściu do innej sekcji  
- ✅ Podświetlanie aktywnych pozycji w menu i podmenu
- ✅ Poprawne użycie Bootstrap collapse z `aria-expanded` i klasą `show`
- ✅ Wzorzec gotowy do wykorzystania w nowych modułach

System AssetHub jest teraz gotowy na skalę enterprise z nowoczesnymi wzorcami architektonicznymi, kompleksowym systemem bezpieczeństwa i audytu, oraz pełnym pokryciem testami!